# 目录

1. 七大原则
2. 23种设计模式

# 目的

1. 降低耦合性
2. 增加内聚性
3. 增加可维护性

# 前提

## 1. 依赖关系

* 只要是类中用到了对方，那么他们之间就存在依赖关系

## 2. 泛化关系

* 泛化关系实际上就是继承关系，是**依赖关系**的特例

## 3. 实现关系

* 对接口的实现，是**依赖关系**的特例

## 4. 关联关系

* 类与类之间的联系

* 关联关系具有**导航性**，即**双向关系**或**单向关系**

* 关联关系具有多重性

* 是**依赖关系**的特例

## 5. 聚合关系

* 表示整体和部分的关系，**整体与部分可以分开**。

* 是**关联关系**的特例

## 6. 组合关系

* 和**聚合关系**差不多，区别在于**整体和部分不可分离**

# 原则

## 1. 单一职责原则

### 介绍

一个类只负责一项职责，如果A中有两个不同的职责，需要将其分为A1,A2

### 案例

![image-20210314160711180](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314160711180.png)

上述代码违反了单一职责原则，因为飞机不能公路上运行

解决：根据交通工具运行方法不同，分解成不同类即可

![image-20210314161211991](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314161211991.png)

![image-20210314161228785](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314161228785.png)

此时遵守单一职责原则，但是产生了一些问题，这样做的改动很大，即将类分解，同时修改客户端。

继续改进：直接修改Vehicle类，改动代码比较少

![image-20210314161654449](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314161654449.png)

![image-20210314161801124](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314161801124.png)

分析:

* 没有对原来的类做大修改，只是增加了方法。
* 虽然没有在类这个级别上遵守单一职责，但是在方法级别上，仍然是遵守单一职责。

### 小结

1. 降低类的复杂度，一个类只负责一个职责
2. 提高类可读性，可维护性
3. 降低变更引起的风险

## 2. 接口隔离原则

### 介绍

客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上

### 案例

![image-20210314164040574](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314164040574.png)

```java
package com.atguigu.principle.segregation;

public class Segregation1 {
    public static void main(String[] args) {

    }
}

interface Interface1 {
    void operation1();
    void operation2();
    void operation3();
    void operation4();
    void operation5();
}

class B implements Interface1 {

    public void operation1() {
        System.out.println("B_operation1");
    }

    public void operation2() {
        System.out.println("B_operation2");
    }

    public void operation3() {
        System.out.println("B_operation3");
    }

    public void operation4() {
        System.out.println("B_operation4");
    }

    public void operation5() {
        System.out.println("B_operation5");
    }
}

class D implements Interface1 {

    public void operation1() {
        System.out.println("D_operation1");
    }

    public void operation2() {
        System.out.println("D_operation2");
    }

    public void operation3() {
        System.out.println("D_operation3");
    }

    public void operation4() {
        System.out.println("D_operation4");
    }

    public void operation5() {
        System.out.println("D_operation5");
    }
}

class A {   // A类只使用接口中的123方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend2(Interface1 i) {
        i.operation2();
    }
    public void depend3(Interface1 i) {
        i.operation3();
    }
}

class C {  // C类只使用接口中145方法
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend4(Interface1 i) {
        i.operation4();
    }
    public void depend5(Interface1 i) {
        i.operation5();
    }
}

```

分析：

* 优点：实现了类图中的要求
* 缺点：违反接口隔离原则

解决：将接口interface拆分成为独立的几个接口，类A和类C分别与它们需要的接口建立依赖关系，也就是采用接口隔离原则

![image-20210314165531932](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314165531932.png)

```java
package com.atguigu.principle.segregation.improve;

public class Segregation1 {
    public static void main(String[] args) {
        // 使用
        A a = new A();
        a.depend1(new B());  // A类通过接口去依赖B类
        a.depend2(new B());
        a.depend3(new B());

        C c = new C();
        c.depend1(new D());  // C类通过接口去依赖D类
        c.depend4(new D());
        c.depend5(new D());
    }
}

// 接口1
interface Interface1 {
    void operation1();
}
// 接口2
interface Interface2 {
    void operation2();
    void operation3();
}
// 接口3
interface Interface3 {
    void operation4();
    void operation5();
}

class B implements Interface1,Interface2 {

    public void operation1() {
        System.out.println("B_operation1");
    }

    public void operation2() {
        System.out.println("B_operation2");
    }

    public void operation3() {
        System.out.println("B_operation3");
    }

}

class D implements Interface1,Interface3 {

    public void operation1() {
        System.out.println("D_operation1");
    }

    public void operation4() {
        System.out.println("D_operation4");
    }

    public void operation5() {
        System.out.println("D_operation5");
    }
}

class A {   // A类只使用接口中的123方法,通过接口1和2
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend2(Interface2 i) {
        i.operation2();
    }
    public void depend3(Interface2 i) {
        i.operation3();
    }
}

class C {  // C类只使用接口中145方法，通过接口1和3
    public void depend1(Interface1 i) {
        i.operation1();
    }
    public void depend4(Interface3 i) {
        i.operation4();
    }
    public void depend5(Interface3 i) {
        i.operation5();
    }
}

```

![image-20210314170202502](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314170202502.png)

### 小结

将大接口的方法根据需要拆分成数个小接口，然后按需implement

## 3. 依赖倒转原则

### 介绍

1. 高层模块不应该依赖底层模块，二者都应该依赖其抽象。
2. 抽象不应该依赖细节，细节应该依赖抽象。
3. 中心思想是面向接口编程，以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。
4. 接口和抽象类得目的是制定好规范，在于设计方面，不会设计具体操作，将细节交给子类实现。

### 案例

```java
package com.atguigu.principle.inversion;

public class DependencyInversion {
    public static void main(String[] args) {
        Person person = new Person();
        person.receive(new Email());
    }
}

class Email {
    public String getInfo() {
        return "电子邮件信息：hello,world";
    }
}

// 完成Person接收消息的功能
class Person {
    public void receive(Email email) {
        System.out.println(email.getInfo());
    }
}

```

![image-20210314171302486](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314171302486.png)

分析：

* 简单，容易想到
* 如果获取的对象是微信、短信等，则需要增加类，同时Person也要增加响应的接收方法

解决：

* 引入一个抽象的接口IReceiver，表示接收者，这样Person类与接口发生依赖
* 因为Email、Weixin等属于接收的范围，他们各自实现IReceiver接口就ok，这样就符合依赖倒转原则

```java
package com.atguigu.principle.inversion.improve;

public class DependencyInversion {
    public static void main(String[] args) {
        // 客户端无需改变
        Person person = new Person();
        person.receive(new Email());
        person.receive(new WeiXin());
    }
}

// 定义接口
interface IReceiver {
    public String getInfo();
}

class Email implements IReceiver {
    public String getInfo() {
        return "电子邮件信息：hello,world";
    }
}

// 增加微信
class WeiXin implements IReceiver{

    public String getInfo() {
        return "微信消息：hello,world";
    }
}

// 完成Person接收消息的功能
class Person {
    public void receive(IReceiver receiver) {
        System.out.println(receiver.getInfo());
    }
}

```

![image-20210314172036988](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314172036988.png)

### 小结

1. 底层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
2. 在中间存在抽象层时，相当于存在一个缓冲层，有利于程序扩展和优化

## 4. 里氏替换原则

### 介绍

主要是针对在编程中，如何**正确的使用继承**，就是里氏替换原则

* **OO中继承性的思考和说明**

  * 父类不强制要求子类必须遵循这些规范，但是如果子类对这些已经实现的方法任意更改，就会对整个继承体系造成破坏

  * 继承在带来便利的同时，也带来了弊端，会给程序带来侵入性，可移植性降低，增加对象间的耦合性
  * 当父类更改时，需要考虑所有的子类，所有设计的子类的功能都可能产生故障

* **基本概念**
  * 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型。

### 案例

![image-20210314180054558](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314180054558.png)

```java
package com.atguigu.principle.liskov;

public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3="+a.func1(11,3));
        System.out.println("1-8="+a.func1(1,8));

        System.out.println("-------------------");
        B b = new B();
        System.out.println("11-3="+b.func1(11,3));
        System.out.println("1-8="+b.func1(1,8));
        System.out.println("11+3+9="+b.func2(11,3));
    }
}

class A {
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends A {
    // 有意或者无意重写了方法
    public int func1(int a, int b) {
        return a+b;
    }
    public int func2(int a, int b) {
        return func1(a,b) + 9;
    }
}

```

![image-20210314175427302](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314175427302.png)

分析：此时因子类的方法重写导致结果出错

解决：让原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用**依赖，聚合，组合**等关系代替

![image-20210314180557626](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314180557626.png)

```java
package com.atguigu.principle.liskov.improve;

public class Liskov {
    public static void main(String[] args) {
        A a = new A();
        System.out.println("11-3="+a.func1(11,3));
        System.out.println("1-8="+a.func1(1,8));

        System.out.println("-------------------");
        B b = new B();
        // 因为B类不再继承A类，因此调用者不会再认为func1是求减法
        // 调用功能就会很明确
        System.out.println("11+3="+b.func1(11,3));
        System.out.println("1+8="+b.func1(1,8));
        System.out.println("11+3+9="+b.func2(11,3));

        // 使用组合仍然可以使用A类相关方法
        System.out.println("11-3="+b.func3(11,3));
    }
}

// 更加基础的基类
class Base {
    // 包含其他更加基础的方法
}

class A extends Base {
    public int func1(int num1, int num2) {
        return num1 - num2;
    }
}

class B extends Base {

    // 如果B需要使用A类方法，使用组合关系
    private A a = new A();

    // 有意或者无意重写了方法
    public int func1(int a, int b) {
        return a+b;
    }
    public int func2(int a, int b) {
        return func1(a,b) + 9;
    }

    // 使用A的方法
    public int func3(int a, int b) {
        return this.a.func1(a,b);
    }
}

```

![image-20210314180902535](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210314180902535.png)

### 小结

> 1. 使用继承时，遵循里氏替换原则，在子类中**尽量**不要重写父类的方法
> 2. 在适当情况下，可以通过**聚合，组合，依赖**来解决问题

## 5. 开闭原则ocp

### 介绍

1. 开闭原则是编程中**最基础、最重要**的设计原则
2. 一个软件实体如类，模块和函数应该**对扩展开放（对提供方），对修改关闭（对使用方）**。用抽象构建框架，用实现扩展细节。
3. 当软件需要变化时，尽量通过**扩展**软件实体的行为来实现变化，而不是通过修改已有代码来实现变化。

4. 编程中遵循其他原则，以及使用设计模式的目的就是遵循开闭原则

### 案例

```java
package com.atguigu.principle.ocp;

public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
    }
}

// 用于绘图的类
class GraphicEditor {
    public void drawShape(Shape s) {
        if (s.m_type == 1) {
            drawRectangle(s);
        } else if (s.m_type == 2) {
            drawCircle(s);
        }
    }

    public void drawRectangle(Shape r) {
        System.out.println("矩形");
    }

    public void drawCircle(Shape r) {
        System.out.println("圆形");
    }
}

class Rectangle extends Shape {
    Rectangle(){
        super.m_type = 1;
    }
}

class Circle extends Shape {
    Circle(){
        super.m_type = 2;
    }
}

class Shape {
    int m_type;
}

```

![image-20210315211847159](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210315211847159.png)

分析：

1. 好理解，易操作
2. 违反了设计模式的ocp原则，即对**扩展开发(提供方)，对修改关闭(使用方)**。

解决：把Shape类做成抽象类，并提供一个抽象的draw方法

```java
package com.atguigu.principle.ocp.improve;

public class Ocp {
    public static void main(String[] args) {
        GraphicEditor graphicEditor = new GraphicEditor();
        graphicEditor.drawShape(new Rectangle());
        graphicEditor.drawShape(new Circle());
        graphicEditor.drawShape(new Triangle());
    }
}

// 用于绘图的类
class GraphicEditor {
    public void drawShape(Shape s) {
        s.draw();
    }
}

class Rectangle extends Shape {
    Rectangle(){
        super.m_type = 1;
    }

    public void draw() {
        System.out.println("绘制矩形");
    }
}

class Circle extends Shape {
    Circle(){
        super.m_type = 2;
    }

    public void draw() {
        System.out.println("绘制圆形");
    }
}

// 新增图形，只需要增加子类，就可以达到扩展的效果
class Triangle extends Shape {

    Triangle() {
        super.m_type = 3;
    }

    public void draw() {
        System.out.println("绘制三角形");
    }
}

abstract class Shape {
    int m_type;

    public abstract void draw(); // 抽象方法
}

```

![image-20210315212818164](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210315212818164.png)

### 小结

相当于对于开发方，增加功能时，不能够修改原有的功能，而是通过增加功能块来实现目的，改动尽量小。

## 6. 迪米特法则

### 介绍

1. 一个对象应该对其他对象保持最少的了解
2. 类与类关系越密切，耦合度越大
3. 又称**最少知道原则**，一个类对外除了提供的public方法，不对外泄露任何消息
4. 只与直接朋友（出现在成员变量，方法参数，方法返回值中的类称为直接朋友，出现在局部变量的类不是直接朋友）进行通信

### 案例

要求：有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工ID

```java
package com.atguigu.principle.demeter;

import java.util.ArrayList;
import java.util.List;

public class Demeter1 {

    public static void main(String[] args) {
        SchoolManager schoolManager = new SchoolManager();
        schoolManager.printAllEmployee(new CollegeManager());

    }

}

// 学校总部员工
class Employee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

// 学院员工
class CollegeEmployee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

// 管理学院员工的管理类
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) {  // 增加10个员工
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }
}


class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();

        for (int i = 0; i < 5; i++) {  // 增加5个员工
            Employee emp = new Employee();
            emp.setId("学校总部员工id= " + i);
            list.add(emp);
        }
        return list;
    }

    // 输出学校总部和学院员工信息
    void printAllEmployee(CollegeManager sub) {

        List<CollegeEmployee> list1 = sub.getAllEmployee();
        System.out.println("------------分公司员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}

```

![image-20210315214815498](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210315214815498.png)

分析：

此时SchoolManager的

* 直接朋友：Employee,ColleageManager

* 不是直接朋友：ColleageManager

以上违背了迪米特法则，ColleageManager是以局部变量的方式出现在SchoolManager

解决：

```java
package com.atguigu.principle.demeter.improve;

import java.util.ArrayList;
import java.util.List;

public class Demeter1 {

    public static void main(String[] args) {
        SchoolManager schoolManager = new SchoolManager();
        schoolManager.printAllEmployee(new CollegeManager());

    }

}

// 学校总部员工
class Employee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

// 学院员工
class CollegeEmployee {
    private String id;

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }
}

// 管理学院员工的管理类
class CollegeManager {
    public List<CollegeEmployee> getAllEmployee() {
        List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
        for (int i = 0; i < 10; i++) {  // 增加10个员工
            CollegeEmployee emp = new CollegeEmployee();
            emp.setId("学院员工id= " + i);
            list.add(emp);
        }
        return list;
    }

    // 输出学院员工的信息
    public void printEmployee() {
        List<CollegeEmployee> list1 = this.getAllEmployee();
        System.out.println("------------分公司员工------------");
        for (CollegeEmployee e : list1) {
            System.out.println(e.getId());
        }
    }
}


class SchoolManager {
    public List<Employee> getAllEmployee() {
        List<Employee> list = new ArrayList<Employee>();

        for (int i = 0; i < 5; i++) {  // 增加5个员工
            Employee emp = new Employee();
            emp.setId("学校总部员工id= " + i);
            list.add(emp);
        }
        return list;
    }

    // 输出学校总部和学院员工信息
    void printAllEmployee(CollegeManager sub) {

        // 将输出学院员工的方法封装到CollegeManager中
        sub.printEmployee();

        List<Employee> list2 = this.getAllEmployee();
        System.out.println("------------学校总部员工------------");
        for (Employee e : list2) {
            System.out.println(e.getId());
        }
    }
}

```

### 小结

1. 主要是封装的思想，需要将各自类或函数的功能进行归类，而不是在别人的类中实现自己的方法
2. 类与类之间只关心所提供出来的public
3. 一个类不关心其他类中的细节

## 7. 合成复用原则

### 介绍

尽量使用合成/聚合的方式，而不是使用继承

![image-20210315221019257](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210315221019257.png)

### 小结

1. 找出应用中可能需要变化之处，独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
3. 为了交互对象之间的松耦合设计而努力

# 分类

## 1. 创建型模式

**单例模式**、抽象工厂模式、原型模式、建造者模式、**工厂模式**

## 2. 结构性模式

适配器模式、桥接模式、**装饰模式**、组合模式、外观模式、享元模式、**代理模式**

## 3. 行为型模式

模板方法模式、命令模式、访问者模式、迭代器模式、**观察者模式**、中介者模式、备忘录模式、解释器模式（Interpreter模式）、状态模式、策略模式、职责链模式（责任链模式）

# 详讲

## 1. 单例模式

> 采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）

### 实现方式

1. 饿汉式（静态常量）

2. 饿汉式（静态代码块）

3. 懒汉式（需要用到双重锁防止线程不同步）

4. 静态内部类（类的装载是线程安全的，所以不用加锁）

   ![image-20210328232147260](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210328232147260.png)

5. 枚举

   ![image-20210328232322372](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210328232322372.png)

### 例子

1. JDK中，java.lang.Runtime就是一个单例模式

   ![image-20210328232529382](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210328232529382.png)

## 2. 简单工厂模式

### 前提概念

1. 产品：类的实例
2. 抽象产品：抽象类、接口
3. 产品簇：多个有内在联系（关系）的产品，比如（汉堡包+可乐）
4. 产品等级：相同类型的产品

例：

![image-20210329175136566](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210329175136566.png)

### 例子

```java
package com.atguigu.principle.factory.simpleFactory;

interface Food {
    public void eat();
}

class Hamburger implements Food {

    public void eat() {
        System.out.println("吃汉堡包");
    }
}
// 开发者
// =========================================
// 使用者
public class SimpleFactory {
    public static void main(String[] args) {
        Food food = new Hamburger();
        food.eat();
    }

}
```

此时的缺点：

当开发者改动了Hamburger的名字，那么使用者也必须改动，形成了耦合的关系

解决：

```java
package com.atguigu.principle.factory.simpleFactory.improve;

interface Food {
    public void eat();
}

class Hamburger implements Food {

    public void eat() {
        System.out.println("吃汉堡包");
    }
}

class Rice implements Food {

    public void eat() {
        System.out.println("吃米饭");
    }
}

class FoodFactory {
    public static Food getFood(int n) {
        Food food = null;
        switch (n) {
            case 1:
                food = new Hamburger();
                break;
            case 2:
                food = new Rice();
                break;
        }
        return food;
    }
}
// 开发者
// =========================================
// 使用者
public class SimpleFactoryImprove {
    public static void main(String[] args) {
        Food food = FoodFactory.getFood(2);
        food.eat();
    }
}

```

此时使用者只用记住1是汉堡包，2是米饭，达到解耦效果，此时开发者只用改动他所知道的部分，而使用者并不关心内部细节

### 优点

1. 把具体产品的类型，从客户端代码中，解耦出来
2. 服务器端，如果修改了具体产品的类名，客户端也不知道，这便符合面向接口编程的思想

### 缺点

1. 客户端需要硬背产品的映射关系，如1->汉堡包，2->米饭
2. 如果产品特别多，则简单工厂，就会变得十分臃肿，比如由100个具体产品，就需要100个case
3. 最重要的是，需求变了，客户端需要扩展具体产品的时候，势必要修改简单工厂中的代码，违反了开闭原则

## 3. 工厂模式

> 约定大于配置
>
> 业务类名改动频繁，所以就会牵扯到其他依赖也跟着更改，工厂类是IT界的约定，类名改动非常小

```java
package com.atguigu.principle.factory.factoryWay;

interface Food {
    public void eat();
}

class Hamburger implements Food {

    public void eat() {
        System.out.println("吃汉堡包");
    }
}

class Rice implements Food {

    public void eat() {
        System.out.println("吃米饭");
    }
}

interface FoodFactory {
    public Food getFood();
}

class HamburgerFactory implements FoodFactory {
    public Food getFood() {
        return new Hamburger();
    }
}

class RiceFactory implements FoodFactory {
    public Food getFood() {
        return new Rice();
    }
}
// 开发者开发的业务框架代码
class Bussiness {
    public void taste(FoodFactory ff) {
        Food f = ff.getFood();
        f.eat();
    } 
}

// 开发者
// =========================================
// 使用者

class liangPi implements Food {

    public void eat() {
        System.out.println("吃凉皮");
    }
}

class LpFactory implements FoodFactory {
    public Food getFood() {
        return new liangPi();
    }
}

public class FactoryWay {

    public static void main(String[] args) {
        Bussiness bussiness = new Bussiness();
        bussiness.taste(new LpFactory());
    }
}

```

此时，如果使用者想增加凉皮这个食物，那么只需要本地修改代码，而不用动开发者的代码

### 优点

1. 仍然具有简单工厂优点，服务器端修改了具体产品的类名后，客户端不知道改动
2. 当客户端需要扩展一个新的产品时，不需要修改作者原来的代码，只是扩展一个新的工厂而已
3. 本地配套一个工厂类的目的是，将自己的代码融入到开发者开发的框架代码中，可以增加代码的扩展性

### 缺点

​	1. 客户端代码膨胀

## 4. 抽象工厂模式

如果按照工厂模式的概念涉及代码，类的代码会急剧增多，比如增加了饮料类

```java
package com.atguigu.principle.factory.abstractFactory;

import java.text.DateFormat;

interface Food {
    public void eat();
}

class Hamburger implements Food {

    public void eat() {
        System.out.println("吃汉堡包");
    }
}

class Rice implements Food {

    public void eat() {
        System.out.println("吃米饭");
    }
}

interface FoodFactory {
    public Food getFood();
}

class HamburgerFactory implements FoodFactory {
    public Food getFood() {
        return new Hamburger();
    }
}

class RiceFactory implements FoodFactory {
    public Food getFood() {
        return new Rice();
    }
}

// ------->新增代码
interface Drink {
    public void drink();
}

class Cola implements Drink {

    public void drink() {
        System.out.println("喝可乐");
    }
}

class Bear implements Drink {

    public void drink() {
        System.out.println("喝啤酒");
    }
}

interface DrinkFactory {
    public Drink getDrink();
}

class ColaFactory implements DrinkFactory {

    public Drink getDrink() {
        return new Cola();
    }
}

class BearFactory implements DrinkFactory {

    public Drink getDrink() {
        return new Bear();
    }
}
// -------->

// 开发者开发的业务框架代码
class Bussiness {
    public void taste(FoodFactory ff) {
        Food f = ff.getFood();
        f.eat();
    }
}

// 开发者
// =========================================
// 使用者

public class AbstractFactory {

    public static void main(String[] args) {
        Bussiness bussiness = new Bussiness();
        bussiness.taste(new LpFactory());
    }
}

```

解决，将两个工厂再往上抽象，抽象成一个总工厂，如下

```java
package com.atguigu.principle.factory.abstractFactory;

import com.atguigu.principle.factory.factoryWay.LpFactory;
import com.atguigu.principle.factory.factoryWay.liangPi;

import java.text.DateFormat;

interface Food {
    public void eat();
}

class Hamburger implements Food {

    public void eat() {
        System.out.println("吃汉堡包");
    }
}

class Rice implements Food {

    public void eat() {
        System.out.println("吃米饭");
    }
}

interface Factory {
    public Food getFood();
    public Drink getDrink();
}

class KFCFactory implements Factory {
    public Food getFood() {
        return new Hamburger();
    }

    public Drink getDrink() {
        return new Cola();
    }
}

class NorFactory implements Factory {
    public Food getFood() {
        return new Rice();
    }

    public Drink getDrink() {
        return new Bear();
    }
}

interface Drink {
    public void drink();
}

class Cola implements Drink {

    public void drink() {
        System.out.println("喝可乐");
    }
}

class Bear implements Drink {

    public void drink() {
        System.out.println("喝啤酒");
    }
}

// 开发者开发的业务框架代码
class Bussiness {
    public void taste(Factory ff) {
        Food f = ff.getFood();
        Drink d = ff.getDrink();
        f.eat();
        d.drink();
    }
}

// 开发者
// =========================================
// 使用者

public class AbstractFactory {

    public static void main(String[] args) {
        Bussiness bussiness = new Bussiness();
        bussiness.taste(new KFCFactory());
    }
}

```

此时的类图：

![image-20210329173712316](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210329173712316.png)

### 优点

1. 仍然有简单工厂和工厂方法的优点
2. 更重要的是，抽象工厂把工厂类的数量减少了！无论有多少个产品等级，工厂就一套

### 缺点

1. 当产品等级发生变化时，都要引起所有以前工厂代码的修改，违反了”开闭原则“

### 讨论

1. 抽象工厂中，可以生产多个产品，但产品之间需要有内在联系，不能乱搭配，如大葱+咖啡
2. 当产品等级比较固定时，可以考虑使用抽象工厂

## 5. 原型模式

### 概念

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
>
> 允许一个对象在创建另一个可定制的对象，无需知道如何创建的细节

### 需求

> 复制出一个一摸一样的TOM羊

### 传统例子

UML图

![image-20210411150232410](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210411150232410.png)

```java
package com.atguigu.principle.prototype;

public class Client {
    public static void main(String[] args) {
        // 传统方法
        Sheep sheep = new Sheep("tom", 1, "白色");

        Sheep sheep1 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep2 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
        Sheep sheep3 = new Sheep(sheep.getName(), sheep.getAge(), sheep.getColor());
    
    }
}
```

缺点：

1. 在创建新的对象时，总是需要重新获取原始对象的属性，效率低

 	2. 总是需要重新初始化对象，不是动态地获取对象运行时的状态，不够灵活

改进思路：

​	Object中的clone()方法，该方法可以将一个java对象复制一份，但是需要实现clone的java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力--->**原型模式**

### 改进例子

```java
package com.atguigu.principle.prototype.improve;

public class Sheep implements Cloneable {
    private String name;
    private int age;
    private String color;

    public Sheep(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    @Override
    public String toString() {
        return "Sheep{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", color='" + color + '\'' +
                '}';
    }

    // 克隆该实例，使用默认的clone方法来完成
    @Override
    protected Object clone(){
        Sheep sheep = null;
        try {
            sheep = (Sheep)super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return sheep;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }
}

```

```java
package com.atguigu.principle.prototype.improve;


public class Client {
    public static void main(String[] args) {
        Sheep sheep = new Sheep("tom", 1, "白色");
        Sheep sheep1 = (Sheep)sheep.clone(); //克隆
        Sheep sheep2 = (Sheep)sheep.clone(); //克隆
        Sheep sheep3 = (Sheep)sheep.clone(); //克隆
    }
}
```

此时如果sheep增加了其他属性，那么其他sheep也会同时加入此属性

### 框架中的例子

Spring中原型bean的创建，就是原型模式的应用

### 浅拷贝

> 对于数据类型是**基本数据类型**的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象
>
> 对于数据类型是**引用数据类型**的成员变量，那么浅拷贝会进行引用传递，所克隆出来的对象中的引用类型成员变量实际上都是指向一个对象，此时并不是真正的复制，**只是指针指向**。

### 深拷贝

> 复制对象的所有基本数据类型的成员变量值
>
> 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象，也就是说，**对象进行深拷贝要对整个对象进行拷贝**

实现：

 1. 重写clone方法实现深拷贝

    ```java
    @Override
        protected Object clone(){
            Object deep = null;
            try {
                // 先处理基本数据类型
                deep = (deep)super.clone();
                // 再处理引用类型
                DeepProtoType deepPrototype = (DeepProtoType)deep;
                deepPrototype.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
            return deepPrototype;
        }
    ```

 2. 通过对象序列化实现深拷贝

    ```java
    public Object deepClone() {
    
            // 创建该对象
            ByteArrayOutputStream bos = null;
            ObjectOutputStream oos = null;
            ByteArrayInputStream bis = null;
            ObjectInputStream ois = null;
    
            try {
                // 序列化
                bos = new ByteArrayOutputStream();
                oos = new ObjectOutputStream(bos);
                oos.writeObject(this);
    
                // 反序列化
                bis = new ByteArrayInputStream(bos.toByteArray());
                ois = new ObjectInputStream(bis);
                DeepPrototype copyObj = (DeepPrototype) ois.readObject();
                return copyObj;
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            } finally {
                try {
                    bos.close();
                    oos.close();
                    bis.close();
                    ois.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    ```

### 优点

1. 简化对象创建过程，提高效率
2. 不用重新初始化对象，动态的获得对象运行时的状态
3. 原始对象发生变化时，其克隆的对象也会发生响应的变化，无需修改代码

### 缺点

​	需要为每一个类配备一个克隆方法，这对全新的类并不难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则。

## 6. 建造者模式

### 概念

> **建造者模式**又叫生成器模式，是一种对象构建模式。它可以将复杂对象的构建过程抽象出来，使这个抽象过程的不同实现方式可以构造出不同表现（属性）的对象
>
> **建造者模式**是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构造它们，用户不需要知道内部的具体构建细节
>
> 与工厂模式不同的是，建造者模式面向的是产品创建的各个步骤，而工厂模式面向的是产品的创建

### 角色

1. Product（产品角色）：一个具体的产品对象
2. Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类，像普遍的工人。
3. ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件，像具体的工人，比如砌墙工。
4. Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用：一是隔离了客户与对象的生产过程，二是复杂控制产品对象的生产过程，像包工头，负责具体的交付。

![image-20210411163620880](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210411163620880.png)

### 需求

> 建房

### 传统例子

![image-20210411160419900](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210411160419900.png)

优点：

​	好理解，简单易操作

缺点：

​	没有涉及缓存层对象，把产品和创建产品的过程装在一起，耦合性增强

解决方案：

​	将**产品**和产品建造**过程**解耦-->**建造者模式**

### 改进例子

![image-20210411164600782](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210411164600782.png)

解释：

​	House是待生产的产品

​	HouseBuilder中描述了盖房中需要的要素动作，但是没有指明它们之间的顺序，可以便于添加其它步骤，比如安窗户等

​	HouseDirector负责HouseBuilder中每个步骤的执行先后顺序

​	CommonHouse和HighBuilding来负责完成具体的操作细节，变成具体的建造者

### 框架中的例子

StringBuilder

## 7. 适配器模式

### 概念

> 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示 ，主要目的是**兼容性**，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器(Wrapper)
>
> 适配器模式属于结构性模式
>
> 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

### 需求

手机充电，由220V转为手机需求的5V

### 例子--->类适配器

![image-20210417113104130](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210417113104130.png)

解释：

​	原本是只能输出220V的电压，通过电压适配器（VoltageAdapter）来实现220向5的转换，而手机（Phone）只需要调用Voltage5V就可以实现充电

#### 代码

```java
package com.atguigu.principle.adapter.classadapter;

public class Voltage220V {
    // 输出220V的电压
    public int output220V() {
        int src = 220;
        System.out.println("电压="+src+"V");
        return src;
    }
}
```

```java
package com.atguigu.principle.adapter.classadapter;

// 适配接口
public interface Voltage5V {
    public int output5V();
}

```

```java
package com.atguigu.principle.adapter.classadapter;

// 适配器类
public class VoltageAdapter extends Voltage220V implements Voltage5V {
    public int output5V() {
        // 获取到220V电压
        int src = output220V();
        int dst = src / 44;  //转成5V
        return dst;
    }
}

```

```java
package com.atguigu.principle.adapter.classadapter;

public class Phone {

    // 充电
    public void charging(Voltage5V v) {
        if (v.output5V() == 5) {
            System.out.println("电压为5V，可以充电");
        } else if (v.output5V() > 5){
            System.out.println("电压过高，无法充电");
        }
    }
}

```

```java
package com.atguigu.principle.adapter.classadapter;

public class Client {
    public static void main(String[] args) {
        System.out.println("======类适配器模式=======");
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());
    }
}

```

#### 总结

> 1. Java是单继承机制，所以类适配需要继承src类这一点算是一个缺点，因为这要求dst必须是一个接口，有一定局限性
> 2. src类的方法在Adapter中都会暴露出来，也增加了使用的成本
> 3. 由于其继承了src类，所以它可以根据需求重写src的方法，使得Adapter的灵活性增强了

### 例子--->对象适配器

![image-20210417115423098](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210417115423098.png)

解释：

​	此时和类适配器大体相同，区别在于从继承关系变成了**聚合关系**

#### 代码改进

```java
package com.atguigu.principle.adapter.objectadapter;

// 适配器类
public class VoltageAdapter implements Voltage5V {
    private Voltage220V voltage220V;
    
    // 通过构造器，传入一个Voltage220V的实例
    VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }
    
    public int output5V() {
        // 获取到220V电压
        int src = voltage220V.output220V();
        int dst = src / 44;  //转成5V
        return dst;
    }
}

```

```java
package com.atguigu.principle.adapter.objectadapter;

public class Client {
    public static void main(String[] args) {
        System.out.println("======对象适配器模式=======");
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter(new Voltage220V()));
    }
}

```

#### 总结

> 1. 基本思路和类的适配器模式相同，只是将Adapter类做修改，不是继承src类，而是**持有src的实例**，完成src->dst的适配
> 2. 根据“合成复用原则”，在系统中尽量使用关联关系来代替继承关系
> 3. **对象适配器模式是适配器模式常用的一种**

### 例子--->接口适配器

![image-20210417121155263](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210417121155263.png)

#### 代码

```java
package com.atguigu.principle.adapter.interfaceadapter;

public interface Interface4 {
    public void operation1();
    public void operation2();
    public void operation3();
    public void operation4();
}

```

```java
package com.atguigu.principle.adapter.interfaceadapter;

public abstract class AbsAdapter implements Interface4{
    // 默认实现
    public void operation1() {

    }

    public void operation2() {

    }

    public void operation3() {

    }

    public void operation4() {

    }
}

```

```java
package com.atguigu.principle.adapter.interfaceadapter;

public class Client {
    public static void main(String[] args) {
        AbsAdapter absAdapter = new AbsAdapter() {
            // 只需要区覆盖我们需要使用的接口方法
            @Override
            public void operation1() {
                System.out.println("使用了方法1");
            }
        };

        absAdapter.operation1();
    }
}

```

#### 总结

> 1. 别名或者被称为缺省适配器模式
> 2. 当不需要全部实现接口提供的方法时，可先涉及一个抽象类实现接口，并为该接口中每个方法提供一个默认实现，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
> 3. 适用于一个接口不想使用其所有方法的情况

### 框架中的例子

SpringMVC中的HandlerAdapter

获取过程：

	1. 通过不同的controller执行getHandler(Controller)方法获取不同的适配器，这个适配器是一个接口，底层有多个实现类
 	2. 调用适配器中方法handler(Controller)，此时是执行了不同实现类的实现方法

## 8.桥接模式

### 概念

> 桥接模式是指将实现(Implementation)和抽象(Abstraction)放在两个不同的类层次中，使两个层次可以独立改变
>
> 是一种结构性设计模式
>
> 基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。

### 需求

手机操作问题

### 传统例子

![image-20210417141619275](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210417141619275.png)

问题分析：

	1. 扩展性问题，如果再增加手机样式，会增加许多的冗余类，类爆炸
 	2. 违反单一职责原则，当我们增加手机样式时，同时要增加所有品牌的手机，增加代码维护成本

解决方案：桥接模式

### 改进例子

![image-20210417144224425](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210417144224425.png)

```java
package com.atguigu.principle.bridge;

public interface Brand {
    void open();
    void close();
    void call();
}
```

```java
package com.atguigu.principle.bridge;

public class Vivo implements Brand {
    public void open() {
        System.out.println("vivo手机开机");
    }

    public void close() {
        System.out.println("vivo手机关机");
    }

    public void call() {
        System.out.println("vivo手机打电话");
    }
}

```

```java
package com.atguigu.principle.bridge;

public class XiaoMi implements Brand {
    public void open() {
        System.out.println("小米手机开机");
    }

    public void close() {
        System.out.println("小米手机关机");
    }

    public void call() {
        System.out.println("小米手机打电话");
    }
}

```

```java
package com.atguigu.principle.bridge;

public abstract class Phone {
    private Brand brand;

    public Phone(Brand brand) {
        this.brand = brand;
    }

    protected void open() {
        this.brand.open();
    }

    protected void close() {
        this.brand.close();
    }

    protected void call() {
        this.brand.call();
    }
}

```

```java
package com.atguigu.principle.bridge;

// 折叠手机类
public class FoldedPhone extends Phone {
    public FoldedPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println("折叠样式手机");
    }

    public void close() {
        super.close();
        System.out.println("折叠样式手机");
    }

    public void call() {
        super.call();
        System.out.println("折叠样式手机");
    }
}

```

```java
package com.atguigu.principle.bridge;

public class Client {
    public static void main(String[] args) {
        // 获取折叠式手机(样式+品牌)
        Phone phone = new FoldedPhone(new XiaoMi());
        phone.open();
        phone.call();
        phone.close();
    }
}

```

解析：

	1. 此时Phone就充当了桥，将手机的品牌和样式进行区分
 	2. 每个手机将基本功能（开机关机打电话等）抽象成了一个父类，这个父类又组合了各类的品牌，形成了一个桥，可以通达两个方向（基本功能和样式选择）
 	3. 桥接模式多用于多对多的情况

### 框架中的例子

JDBC中的Driver接口，Driver下面可以有MySql的Driver，Oracle的Driver，这些就可以当作接口类

其中Driver和Connection之间是通过DriverManager类进行桥接的。

## 9. 装饰者模式

### 概念

> 装饰者模式：**动态**的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则（ocp）

### 需求

咖啡订单项目

1. 咖啡种类/单品咖啡：Espresso、ShortBlack、LongBlack、Decaf
2. 调料：Milk、Soy、Chocolate
3. 要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
4. 使用OO来计算不同种类咖啡的费用：客户可以点单品咖啡，也可以单品咖啡+调料组合

### 传统例子

把每种组合都形成一个类

缺点：

1. 组合很多，会有很多类，类爆炸

### 改进例子

![image-20210418140630061](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210418140630061.png)

补充：

1. 是将被装饰者组合到装饰品中里

 	2. 比如要巧克力+牛奶+LongBlack，那么先创建**LongBlack**，然后在外面包裹一层**牛奶**，变成**牛奶+LongBlack**，然后再在外面包裹一层**巧克力**，变成**巧克力+牛奶+LongBlack**
 	3. 像个套娃

```java
package com.atguigu.principle.decorator;

public abstract class Drink {

    public String desc; //描述
    private float price = 0.0f;

    // 计算费用的抽象方法
    public abstract float cost();

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

}

```

```java
package com.atguigu.principle.decorator;

public class Coffee extends Drink {
    public float cost() {
        return super.getPrice();
    }
}

```

```java
package com.atguigu.principle.decorator;

public class Espresso extends Coffee {

    public Espresso() {
        setDesc("意大利咖啡");
        setPrice(6.0f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class LongBlack extends Coffee {
    public LongBlack() {
        setDesc("longblack");
        setPrice(5.0f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class ShortBlack extends Coffee {

    public ShortBlack() {
        setDesc("shortblack");
        setPrice(4.0f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class Decorator extends Drink {
    // 组合
    private Drink obj;

    public Decorator(Drink obj) {
        this.obj = obj;
    }

    // super.getPrice()   自己（装饰品）的价格
    // obj.getPrice()     被装饰者价格（单品咖啡）
    public float cost() {
        return super.getPrice() + obj.getPrice();
    }

    // obj.getDesc()   输出被装饰者的信息
    @Override
    public String getDesc() {
        return super.getDesc() + " " + super.getPrice() + " && " + obj.getDesc();
    }
}

```

```java
package com.atguigu.principle.decorator;

// 具体的Decorator，这里就是调味品
public class Chocolate extends Decorator {
    public Chocolate(Drink obj) {
        super(obj);
        setDesc("巧克力");
        setPrice(3.0f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class Milk extends Decorator {
    public Milk(Drink obj) {
        super(obj);
        setDesc("牛奶");
        setPrice(2.0f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class Soy extends Decorator {
    public Soy(Drink obj) {
        super(obj);
        setDesc("豆浆");
        setPrice(1.5f);
    }
}

```

```java
package com.atguigu.principle.decorator;

public class CoffeeBar {
    public static void main(String[] args) {
        // 1. 点一份LongBlack
        Drink order = new LongBlack();
        System.out.println("费用="+order.cost());
        System.out.println("描述="+order.getDesc());

        // 2. order 加一份牛奶
        order = new Milk(order);
        System.out.println("order 加一份牛奶 费用="+order.cost());
        System.out.println("order 加一份牛奶 描述="+order.getDesc());

        // 3. order 再加一份巧克力
        order = new Chocolate(order);
        System.out.println("order 加一份牛奶，巧克力 费用="+order.cost());
        System.out.println("order 加一份牛奶，巧克力 描述="+order.getDesc());
    }
}

```

### 框架中的例子

Java的IO结构，FilterInputStream就是一个装饰者

1. DataInputStream是FilterInputStream的一个子类
2. FilterInputStream继承自InputStream
3. FilterInputStream组合了一个InputStream类型的对象,说明含有一个被装饰者
4. 此时：
   1. DataInputStream=Milk
   2. FilterInputStream=Decorator
   3. InputStream=Drink

## 10. 组合模式

### 概念

> 1. 组合模式又叫做部分整体模式，它创建了对象组的属性结构，将对象组合成树状结构以表示“部分·整体”的层次关系
>
> 2. 组合模式依据**树形结构**来组合对象，用来表示部分以及整体层次。
>
> 3. 这种类型的设计模式属于结构性模式
>
> 4. 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象

### 需求

看一个学校院系展示需求

要在一个页面中展示出学校的院系组成，一个学校有多少学院，一个学院有多少个系

### 传统例子

1. 将学院看作是学校的子类，系堪称学院的子类，这样实际上是站在组织大小来进行分层次的
2. 这种例子不能很好的实现管理操作，比如对学院的添加、删除、遍历等

解决：把学校、院、系**都看作**是组织结构，他们之间没有继承的关系，而是一个属性结构，可以更好的实现管理操作--->**组合模式**

### 改进例子

![image-20210418153038577](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210418153038577.png)

图分析：

1. OraganizationComponent是一个顶部的规范类，规范也叶子结点和非叶子节点的通用行为，具体的细节由实现类实现
2. 用户（Client）通过使用OraganizationComponent来对其中的实现类进行操作
3. 其中Department是叶子结点，其余为非叶子结点

```java
package com.atguigu.principle.composite;

public abstract class OrganizationComponent {

    private String name;
    private String desc;

    public OrganizationComponent(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    protected void add(OrganizationComponent organizationComponent) {
        throw new UnsupportedOperationException();
    }

    protected void remove(OrganizationComponent organizationComponent) {
        throw new UnsupportedOperationException();
    }

    protected abstract void print();
}

```

```java
package com.atguigu.principle.composite;


import java.util.ArrayList;
import java.util.List;

public class University extends OrganizationComponent {

    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    public University(String name, String desc) {
        super(name, desc);
    }

    protected void print() {
        System.out.println("----------"+getName()+"---------");
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }
}

```

```java
package com.atguigu.principle.composite;

import java.util.ArrayList;
import java.util.List;

public class College extends OrganizationComponent {
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    public College(String name, String desc) {
        super(name, desc);
    }

    protected void print() {
        System.out.println("----------"+getName()+"---------");
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }

    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }
}

```

```java
package com.atguigu.principle.composite;

public class Department extends OrganizationComponent {

    //  因为是叶子结点，所有add和remove方法可以不用写了

    public Department(String name, String desc) {
        super(name, desc);
    }

    protected void print() {
        System.out.println(getName());
    }
}

```

```java
package com.atguigu.principle.composite;

public class Client {
    public static void main(String[] args) {
        // 从大到小创建对象
        OrganizationComponent university = new University("清华大学", "中国顶级大学");
        OrganizationComponent computerCollege = new College("计算机学院", "计算机学院");
        OrganizationComponent infoEngineerCollege = new College("信息工程学院", "信息工程学院");

        computerCollege.add(new Department("软件工程","软件工程不错"));
        computerCollege.add(new Department("网络工程","网络工程不错"));
        computerCollege.add(new Department("计算机科学与技术","计算机科学与技术是老牌专业"));

        infoEngineerCollege.add(new Department("通信工程","不好学"));
        infoEngineerCollege.add(new Department("信息工程","很好学"));

        university.add(computerCollege);
        university.add(infoEngineerCollege);

        university.print();
    }
}

```

### 框架中的例子

HashMap中

Map--->HashMap--->Node

解释：

1. Map就是一个抽象的构建（类似Component）
2. HashMap是一个中间的构建（Composite），实现了相关方法
3. Node就是一个叶子结点

## 11. 外观模式

### 概念

> 1. 也叫做“过程模式”，外观模式为子系统中的**一组接口**提供一个一致的界面，此模式定义一个高层接口，这个接口使得这一子系统更加容易使用
> 2. 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

### 需求

影院管理项目

有DVD播放器、投影仪、自动屏幕、环绕立体声、爆米花机等组件，过程为：

1. 用遥控器：统筹各设备开关
2. 开爆米花机
3. 放下屏幕
4. 开投影仪
5. 开音响
6. 开DVD，选DVD
7. 拿爆米花
8. 调暗灯光
9. 播放
10. 结束，关闭各种设备

### 传统例子

​	为每个设备创建一个对象，每个对象中有对应的开、关、启动等方法。

分析：

1. 在main方法中，调用这些对象的方法，当其中一个对象方法发生变化时，需要动main方法中的代码
2. 直接调用子系统（对象）的相关方法，会造成调用过程混乱，没有清晰的过程

解决思路：

1. 定义一个高层接口，给子系统的一组接口提供一个一致的界面，用来访问子系统中的**一群接口**
2. 通过定义一个一致的接口（界面类），用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关系这个子系统的内部细节--->**外观模式**

### 改进例子

![image-20210427135321372](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210427135321372.png)

1. 外观类：为调用端提供**统一的调用接口**，外观类知道哪些子系统负责处理了请求，从而将调用端的请求代理给适当的子系统对象
2. 调用者：外观接口的调用
3. 子系统：指模块或者子系统，处理Facade对象指派的任务，它是功能的实际提供者

因为这个模式过于简单，个人感觉只是简单的封装，所以只贴外观类代码

```java
package com.atguigu.principle.facade;

public class HomeTheaterFacade {

    // 定义各个子系统的对象
    private DVDPlayer dvdPlayer;
    private Popcorn popcorn;
    private Stereo stereo;
    private Projector projector;
    private Screen screen;

    public HomeTheaterFacade() {
        this.dvdPlayer = DVDPlayer.getInstance();
        this.popcorn = Popcorn.getInstance();
        this.stereo = Stereo.getInstance();
        this.projector = Projector.getInstance();
        this.screen = Screen.getInstance();
    }

    // 操作有4步
    public void ready() {
        popcorn.on();
        popcorn.pop();
        screen.down();
        projector.on();
        stereo.on();
        dvdPlayer.on();
    }

    public void play() {
        dvdPlayer.play();
    }

    public void pause() {
        dvdPlayer.pause();
    }

    public void end() {
        popcorn.off();
        screen.up();
        stereo.off();
        projector.off();
        dvdPlayer.off();
    }
}

```

```java
package com.atguigu.principle.facade;

public class Client {
    public static void main(String[] args) {
        // 直接调用很麻烦
        HomeTheaterFacade homeTheaterFacade = new HomeTheaterFacade();
        homeTheaterFacade.ready();
        homeTheaterFacade.play();
        homeTheaterFacade.end();
    }
}

```

## 12. 享元模式

### 概念

> 1. 也称蝇量模式，运用共享技术有效地支持**大量细粒度**的对象
> 2. 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
> 3. 享元模式能够解决**重复对象的内存浪费问题**，当系统中有大量相似对象，需要缓存池时。不需总是创建新对象，可以从缓冲池里拿。这样降低系统内存，提高效率，符合**资源复用**的思想
> 4. 经典应用场景：**池技术**（String常量池、数据库连接池、缓冲池）等等都是享元模式的应用

### 需求

小型外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网站，但是要求都有些不同：

1. 有客户要求以新闻的形式发布
2. 有客户要求以博客的形式发布
3. 有客户要求以微信公众号的形式发布

### 传统例子

1. 直接复制粘贴一份，然后根据客户不同要求，进行定制修改
2. 给每个网站租用一个空间

分析：

​	网站**相似度很高**，相当于一个相同网站的实例对象很多，造成服务器的资源浪费。

解决思路：

​	整合到一个网站中，共享其相关的代码和数据，对于硬盘、内存、CPU、数据库空间等服务器资源都可以达成共享，减少服务器资源浪费--->**享元模式**

### 改进例子

![image-20210427144942976](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210427144942976.png)

FlyWeight：是抽象的享元角色，它是产品的抽象类，同时定义出对象的**外部状态**和**内部状态**的接口或实现

> 内部状态：指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
>
> 外部状态：指对象得以依赖的一个**标记**，是随环境改变而改变的、不可共享的状态。

ConcreteFlyWeight：是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务

UnSharedConcreteFlyWeight：是不可共享的角色，一般不会出现在享元工厂

FlyWeightFactory：享元工厂类，用于构建一个池容器（集合），同时提供从池中获取对象

```java
package com.atguigu.principle.flyweight;

public abstract class WebSite {
    public abstract void use();
}

```

```java
package com.atguigu.principle.flyweight;

// 具体网站
public class ConcreteWebSite extends WebSite {

    private String type = "";  // 网站发布的形式

    public ConcreteWebSite(String type) {
        this.type = type;
    }

    public void use() {
        System.out.println("网站的发布形式为："+type);
    }
}

```

```java
package com.atguigu.principle.flyweight;

import java.util.HashMap;

// 网站工厂类，根据需要返回一个网站
public class WebSiteFactory {

    // 集合，充当池的作用
    private HashMap<String, ConcreteWebSite> pool = new HashMap<String, ConcreteWebSite>();

    // 根据网站的类型，返回一个网站，如果没有就创建一个网站并放到池中
    public WebSite getWebSiteCategory(String type) {
        if (!pool.containsKey(type)) {
            // 创建网站，并放入
            pool.put(type, new ConcreteWebSite(type));
        }

        return pool.get(type);
    }

    // 获取网站分类总数（用于验证）
    public int getWebSiteCount() {
        return pool.size();
    }
}

```

```java
package com.atguigu.principle.flyweight;

public class Client {
    public static void main(String[] args) {
        WebSiteFactory webSiteFactory = new WebSiteFactory();

        // 新闻形式
        WebSite webSite1 = webSiteFactory.getWebSiteCategory("新闻");
        webSite1.use();

        // 博客形式
        WebSite webSite2 = webSiteFactory.getWebSiteCategory("博客");
        webSite2.use();

        // 博客形式
        WebSite webSite3 = webSiteFactory.getWebSiteCategory("博客");
        webSite3.use();

        System.out.println("实例总数："+webSiteFactory.getWebSiteCount());
    }
}

```

### 框架中的例子

Integer.valueOf

## 13. 代理模式

![image-20210501220512913](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210501220512913.png)

### 概念

> 1. 为一个对象**提供一个替身**，以控制对这个对象的访问。即通过代理对象访问目标对象；**好处**是：可以在目标对象实现的基础上，增强额外的功能操作，达到扩展的效果
> 2. 被代理对象适用于远程对象、创建开销大的对象和需要安全控制的对象
> 3. 代理形式：
>    1. 静态代理
>    2. 动态代理（JDK，基于接口）
>    3. cglib代理（基于子类）

### 静态代理

#### 介绍

> 静态代理在使用时，需要定义**接口**或者**父类**，被代理对象与代理对象一起实现相同的接口或者继承相同的父类

#### 应用实例

![image-20210501221830741](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210501221830741.png)

分析：

1. ITeacherDao为抽象方法，作为规范和被代理对象接口使用
2. TeacherDao是实际被代理对象
3. TeacherDaoProxy是代理对象

步骤：

1. TeacherDao实现ITeacherDao所规范的方法，称为实际的类
2. TeacherDaoProxy通过实现接口的方式产生TeacherDao的代理对象
3. TeacherDaoProxy只需要聚合到TeacherDao中即可使用
4. Client在实际使用的是代理对象

#### 代码

```java
package com.atguigu.principle.proxy;

public interface ITeacherDao {
    void teach();
}

```

```java
package com.atguigu.principle.proxy;

public class TeacherDao implements ITeacherDao {
    public void teach() {
        System.out.println("老师授课中...");
    }
}

```

```java
package com.atguigu.principle.proxy;

// 静态代理
public class TeacherProxy implements ITeacherDao {

    // 目标对象，通过接口来聚合
    private ITeacherDao target;

    public TeacherProxy(ITeacherDao target) {
        this.target = target;
    }

    public void teach() {
        System.out.println("代理开始...");
        target.teach();
        System.out.println("代理结束...");
    }
}

```

```java
package com.atguigu.principle.proxy;

public class Client {
    public static void main(String[] args) {
        // 目标对象
        TeacherDao teacherDao = new TeacherDao();

        // 创建代理对象
        TeacherProxy teacherProxy = new TeacherProxy(teacherDao);
        teacherProxy.teach();
    }
}

```

### 动态代理

#### 介绍

1. 代理对象不需要实现接口，但是目标对象仍然要实现接口
2. 利用JDK的API实现代理，在内存中构建代理对象
3. 也称：JDK代理、接口代理

#### API

1. 所在包：java.lang.reflect.Proxy
2. JDK实现代理只需要使用newProxyInstance方法

```java
static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
// ClassLoader:当前对象使用的类加载器，方法固定
// Class：目标对象实现的接口类型，使用泛型方式
// InvocationHandler：事件处理，执行目标对象的方法时，会触发事件处理器方法，会把当前执行的目标对象作为参数
```

#### 应用实例

![image-20210501224131733](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210501224131733.png)

分析：

1. ITeacherDao为抽象方法，作为规范和被代理对象接口使用
2. TeacherDao是实际被代理对象
3. ProxyFactory是代理工厂，返回代理对象
4. Client使用ProxyFactory和TeacherDao实现功能扩展

#### 代码

```java
package com.atguigu.principle.proxy.dynamic;

public interface ITeacherDao {
    void teach();
}

```

```java
package com.atguigu.principle.proxy.dynamic;

public class TeachDao implements ITeacherDao {
    public void teach() {
        System.out.println("老师正在授课中");
    }
}

```

```java
package com.atguigu.principle.proxy.dynamic;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyFactory {

    // 维护一个目标对象
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("JDK代理开始");
                // 反射机制调用目标对象的方法
                Object returnValue = method.invoke(target, args);
                return returnValue;
            }
        });
    }
}

```

```java
package com.atguigu.principle.proxy.dynamic;

public class Client {
    public static void main(String[] args) {
        // 创建目标对象
        TeachDao target = new TeachDao();

        // 代理对象
        ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance();
        proxyInstance.teach();
    }
}

```

### Cglib代理

#### 介绍

1. 目标对象不用必须实现接口，这个时候可以使用**目标对象子类**来实现代理，这就是cglib代理
2. 也称作**子类代理**，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，也属于动态代理
3. 底层是**通过字节码处理框架ASM来转换字节码并生成新的类**

#### 使用说明

1. 引入cglib的jar文件

   1. asm.jar
   2. asm-commons.jar
   3. asm-tree.jar
   4. cglib-2.2.jar

   或者

   ```xml
   <dependency>
               <groupId>cglib</groupId>
               <artifactId>cglib</artifactId>
               <version>2.2.2</version>
           </dependency>
   ```

2. 在内存中动态构建子类，代理的类不能为final

#### 步骤

1. 创建工具类Enhancer（cglib包中）
2. 设置父类（设置成目标对象）
3. 设置回调函数
4. 创建子类对象，即代理对象

#### 应用实例

![image-20210501230540298](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210501230540298.png)

分析：

1. TeacherDao是实际被代理对象
2. ProxyFactory是代理工厂，返回代理对象
3. MethodInterceptor是cglib中的接口，实现其中intercept()方法，实现方法拦截的功能

#### 代码

```java
package com.atguigu.principle.proxy.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class ProxyFactory implements MethodInterceptor {

    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxyInstance() {
        // 1. 创建一个工具类
        Enhancer enhancer = new Enhancer();
        // 2. 设置父类
        enhancer.setSuperclass(target.getClass());
        // 3. 设置回调函数
        enhancer.setCallback(this);
        // 4. 创建子类对象，即代理对象
        return enhancer.create();
    }

    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("cglib代理模式开始");
        Object returnValue = method.invoke(target, objects);
        System.out.println("cglib代理模式结束");
        return returnValue;
    }
}

```

```java
package com.atguigu.principle.proxy.cglib;

public class Client {
    public static void main(String[] args) {
        TeacherDao teacherDao = new TeacherDao();
        TeacherDao proxyInstance = (TeacherDao) new ProxyFactory(teacherDao).getProxyInstance();
        proxyInstance.teach();
    }
}

```

## 14. 模板模式

### 概念

> 1. 又称**模板方法模式**，在一个抽象类公开定义了执行它的方法模板，其子类可以按需要**重写**方法实现，但调用将以抽象类中定义的方法进行。
> 2. 简单说，就是定义了一些方法的骨架，一些额外的方法可以延迟到子类中实现，特殊定义需求方法。

### 需求

豆浆制作

1. 流程：选材--添加配料--浸泡--打碎
2. 不同的配料可以制作出不同口味的豆浆
3. 其他步骤对于不同口味豆浆都是一样的操作

### 改进例子

![image-20210502140455351](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210502140455351.png)

分析：

1. template是模板方法，规定了算法大致流程
2. operationX是具体的执行方法，可以是抽象方法，也可以是具体实现方法

```java
package com.atguigu.principle.template;

public abstract class SoyaMilk {
    // 模板方法，make,可以做成final，不让子类覆盖
    final void make() {
        select();
        addCondiments();
        soak();
        beat();
    }

    // 选材
    void select() {
        System.out.println("第一步：选择好的豆子");
    }

    // 添加不同的配料，抽象，子类具体实现
    abstract void addCondiments();

    // 浸泡
    void soak() {
        System.out.println("第三步：黄豆和配料浸泡");
    }

    // 敲打
    void beat() {
        System.out.println("第三步：打碎");
    }
}

```

```java
package com.atguigu.principle.template;

public class RedBeanSoyaMilk extends SoyaMilk {
    void addCondiments() {
        System.out.println("第二步：加入红豆");
    }
}

```

```java
package com.atguigu.principle.template;

public class Client {
    public static void main(String[] args) {
        SoyaMilk redBean = new RedBeanSoyaMilk();
        redBean.make();
    }
}

```

## 15. 命令模式

### 概念

> 1. 将**请求发送者**与**请求接收者**解耦，让对象之间的调用关系更加灵活
> 2. 将请求封装成一个对象，用不同的参数表示不同的请求
> 3. 同时命令模式也支持可撤销的操作

### 需求

智能生活项目

1. 有一套智能家电，（照明灯、风扇、冰箱、洗衣机），我们只需要安装app就可以控制家电工作
2. 智能家电来自不同的厂商，需要有一个app控制所有的智能家电
3. 需要每个智能家电厂商提供一个统一的接口给app调用---**命令模式**

### 改进例子

![image-20210502145321806](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210502145321806.png)

分析：

1. Invoker是调用者角色
2. Command是命令角色，需要执行的命令都在这里，可以是接口或者抽象类
3. Receiver是接收者角色，知道如何实施和执行一个请求相关操作
4. ConcreteCommand：将一个接收者对象与一个动作绑定，调用接收者相应的操作，实现execute

```java
package com.atguigu.principle.command;

// 命令接口
public interface Command {

    // 执行操作
    void execute();

    // 撤销操作
    void undo();
}

```

```java
package com.atguigu.principle.command;

// 接收者
public class LightReceiver {
    public void on() {
        System.out.println("电灯打开");
    }

    public void off() {
        System.out.println("电灯关闭");
    }

}

```

```java
package com.atguigu.principle.command;

// 开命令
public class LightOnCommand implements Command {

    // 聚合LightReceiver
    LightReceiver light;

    public LightOnCommand(LightReceiver light) {
        this.light = light;
    }

    public void execute() {
        light.on();
    }

    public void undo() {
        light.off();
    }
}

```

```java
package com.atguigu.principle.command;

// 关命令
public class LightOffCommand implements Command {
    // 聚合LightReceiver
    LightReceiver light;

    public LightOffCommand(LightReceiver light) {
        this.light = light;
    }

    public void execute() {
        light.off();
    }

    public void undo() {
        light.on();
    }
}

```

```java
package com.atguigu.principle.command;

// 空命令，对于简化操作，可以省去对空的判断
// 用于初始化每个按钮
public class NoCommand implements Command{
    public void execute() {

    }

    public void undo() {

    }
}

```

```java
package com.atguigu.principle.command;

public class RemoteController {

    // 开 按钮的命令数组
    Command[] onCommands;
    Command[] offCommands;

    // 撤销
    Command undoCommand;

    // 初始化
    public RemoteController() {
        onCommands = new Command[5];
        offCommands = new Command[5];

        for (int i = 0; i < 5; i++) {
            onCommands[i] = new NoCommand();
            offCommands[i] = new NoCommand();
        }
    }

    // 按钮设置
    public void setCommand(int no, Command onCommand, Command offCommand) {
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    // 开按钮
    public void onButtonPushed(int no) {
        onCommands[no].execute();
        // 记录这次操作
        undoCommand = onCommands[no];
    }

    // 关按钮
    public void offButtonPushed(int no) {
        offCommands[no].execute();
        // 记录这次操作
        undoCommand = offCommands[no];
    }

    // 撤销按钮
    public void undoButtonPushed() {
        undoCommand.undo();
    }
}

```

```java
package com.atguigu.principle.command;

public class Client {
    public static void main(String[] args) {
        // 接收者
        LightReceiver light = new LightReceiver();

        // 命令
        LightOnCommand lightOnCommand = new LightOnCommand(light);
        LightOffCommand lightOffCommand = new LightOffCommand(light);

        // 遥控器
        RemoteController remoteController = new RemoteController();

        // 给遥控器设置相关命令
        remoteController.setCommand(0,lightOnCommand,lightOffCommand);

        System.out.println("----------按下开按钮-----------");
        remoteController.onButtonPushed(0);
        System.out.println("----------按下关按钮-----------");
        remoteController.offButtonPushed(0);
        System.out.println("----------按下撤销按钮-----------");
        remoteController.undoButtonPushed();
    }
}

```

## 16. 访问者模式

### 概念

> 1. 封装一些作用域数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
> 2. 将数据结构和数据操作分离，解决**数据结构**和**操作耦合性**问题
> 3. 基本原理是：**在被访问者的类里面加一个对外提供接待访问者的接口**
> 4. 应用场景：需要对一个对象结构中的对象进行很多不同操作，同时要避免这些操作“污染”这些对象的类

### 需求

测评系统

​	观众分为男人和女人，对歌手进行测评（成功、失败等）

### 改进例子

![image-20210505184447812](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210505184447812.png)

分析：

1. Visitor：抽象的访问者，为该对象结构中的ConcreteVisitor的每一个类声明一个visit操作
2. ConcreteVisitor：是一个具体的访问者，实现每个有Visitor声明的操作，是每各操作实现的部分
3. ObjectStructure：能枚举元素，提供一个高层的接口，用来允许访问者访问元素
4. Element：定义一个accpet方法，接收一个访问者对象
5. ConcreteElement为具体元素，实现了accept方法

代码：

```java
package com.atguigu.principle.visitor;

public abstract class Person {
    // 提供一个接口，让访问者可以访问
    public abstract void accept(Action action);
}

```

```java
package com.atguigu.principle.visitor;

public class Man extends Person {
    public void accept(Action action) {
        action.getManResult(this);
    }
}

```

```java
package com.atguigu.principle.visitor;

public class Women extends Person {
    public void accept(Action action) {
        action.getWomenResult(this);
    }
}

```

```java
package com.atguigu.principle.visitor;

public abstract class Action {

    // 得到男性的测评
    public abstract void getManResult(Man man);

    // 得到女性的测评
    public abstract void getWomenResult(Women women);
}

```

```java
package com.atguigu.principle.visitor;

public class Success extends Action {
    public void getManResult(Man man) {
        System.out.println("男人：成功");
    }

    public void getWomenResult(Women women) {
        System.out.println("女人：成功");
    }
}

```

```java
package com.atguigu.principle.visitor;

public class Fail extends Action {
    public void getManResult(Man man) {
        System.out.println("男人：失败");
    }

    public void getWomenResult(Women women) {
        System.out.println("女人：失败");
    }
}
```

```java
package com.atguigu.principle.visitor;

import java.util.LinkedList;
import java.util.List;

public class ObjectStructure {

    private List<Person> persons = new LinkedList<Person>();

    // 添加
    public void attach(Person p) {
        persons.add(p);
    }

    // 移除
    public void detach(Person p) {
        persons.remove(p);
    }

    // 测评情况
    public void display(Action action) {
        for (Person p : persons) {
            p.accept(action);
        }
    }
}
```

```java
package com.atguigu.principle.visitor;

public class Client {
    public static void main(String[] args) {
        ObjectStructure objectStructure = new ObjectStructure();

        objectStructure.attach(new Man());
        objectStructure.attach(new Women());

        // 成功
        Success success = new Success();
        objectStructure.display(success);

        System.out.println("=====================");
        Fail fail = new Fail();
        objectStructure.display(fail);
    }
}
```

说明：

1. 将**评分人**和**评分操作**进行了分离

2. 评分人只需实现accept方法接收评分的状态，那么就可以实现该评分人打了这一个状态的评分

3. 使用了**“双分派”**操作，如Women中，Action传入到Women类中，在调用方法时，又将Women以this的方式传回Action中

   ```mermaid
   sequenceDiagram
   Action->>Women:action(success,fail)
   Women->>Action:this
   ```

4. 在此例子中，Action是可扩展的，Person是固定的，如果需要增加评分状态，则只需要添加一个Action的子类，然后通过objectStructure传递即可

## 17. 迭代器模式

### 概念

> 1. 如果我们的集合元素是用不同的方式实现的，如数组、集合等，当客户端要**遍历**这些元素时就需要使用多种遍历方式，这时可以考虑迭代器模式
> 2. 提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示

### 需求

在一个页面中展示出学校的院系组成，一个学校有多个学院，一个学院有多个系

比如计算机系存储在数组中，信息工程系存储在集合中，如何统一遍历各个不同存储的系？--->**迭代器模式**

### 改进例子

![image-20210509135311877](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210509135311877.png)

分析：

1. Iterator：迭代器接口，系统提供，有三个方法
2. ConcreteIterator：具体的迭代器类，管理迭代器
3. Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦
4. ConcreteAggregate：具体的聚合，持有对象集合，并提供返回迭代器的方法
5. Client：客户端，通过Iterator和Aggregate依赖子类

代码：

```java
package com.atguigu.principle.iterator;

// 系中部门
public class Department {
    private String name;
    private String desc;

    public Department(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }
}

```

```java
package com.atguigu.principle.iterator;

import java.util.Iterator;

// 系接口
public interface College {
    public String getName();

    public void addDepartment(String name, String desc);

    public Iterator createIterator();
}

```

```java
package com.atguigu.principle.iterator;
import java.util.Iterator;

// 计算机系
public class ComputerCollege implements College {

    Department[] departments;
    int numOfDepartment = 0;

    public ComputerCollege() {
        departments = new Department[5];
        addDepartment("Java","java");
        addDepartment("PHP","PHP");
        addDepartment("大数据","大数据");
        addDepartment("C","C");
    }

    public String getName() {
        return "计算机学院";
    }

    public void addDepartment(String name, String desc) {
        Department department = new Department(name, desc);
        departments[numOfDepartment++] = department;

    }

    public Iterator createIterator() {
        return new ComputerCollegeIterator(departments);
    }
}

```

```java
package com.atguigu.principle.iterator;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

// 信息安全系
public class InfoCollege implements College {

    List<Department> departmentList;

    public InfoCollege() {
        departmentList = new ArrayList<Department>();
        addDepartment("信息安全","信息安全");
        addDepartment("网络安全","网络安全");
        addDepartment("服务器安全","服务器安全");
    }

    public String getName() {
        return "信息工程学院";
    }

    public void addDepartment(String name, String desc) {
        Department department = new Department(name, desc);
        departmentList.add(department);
    }

    public Iterator createIterator() {
        return new InfoCollegeIterator(departmentList);
    }
}

```

```java
package com.atguigu.principle.iterator;

import java.util.Iterator;

// 计算机系迭代器
public class ComputerCollegeIterator implements Iterator {
    Department[] departments;
    int index = 0;

    public ComputerCollegeIterator(Department[] departments) {
        this.departments = departments;
    }

    public boolean hasNext() {
        return index < departments.length && departments[index] != null;
    }

    public Object next() {
        return departments[index++];
    }

    public void remove() {

    }
}

```

```java
package com.atguigu.principle.iterator;

import java.util.Iterator;
import java.util.List;

// 信息安全系迭代器
public class InfoCollegeIterator implements Iterator {

    List<Department> departmentList;
    int index = 0;

    public InfoCollegeIterator(List<Department> departmentList) {
        this.departmentList = departmentList;
    }

    public boolean hasNext() {
        return index < departmentList.size();
    }

    public Object next() {
        return departmentList.get(index++);
    }

    public void remove() {

    }
}

```

```java
package com.atguigu.principle.iterator;

import java.util.Iterator;

public class Client {
    public static void main(String[] args) {
        // 计算机学院
        ComputerCollege computerCollege = new ComputerCollege();
        Iterator iterator = computerCollege.createIterator();
        while(iterator.hasNext()) {
            Department next = (Department)iterator.next();
            System.out.println("姓名："+next.getName()+"\t 描述："+next.getDesc());
        }
        System.out.println("=======================");
        // 信息学院
        InfoCollege infoCollege = new InfoCollege();
        Iterator iterator2 = infoCollege.createIterator();
        while(iterator2.hasNext()) {
            Department next = (Department)iterator2.next();
            System.out.println("姓名："+next.getName()+"\t 描述："+next.getDesc());
        }
    }
}

```

## 18. 观察者模式

### 概念

>1. 又称**发布–订阅模式**（有时又称为模型（Model）-视图（View）模式、源-收听者(Listener)模式或从属者模式）。
>2. 观察者模式完美的将观察者和被观察者的对象分离开，举个例子，用户界面作为观察者，业务数据作为被观察者，两者之间存在“观察”的逻辑，用户界面观察业务数据的变化，当被观察者（业务数据）发生变化时，观察者（用户界面）就会观察到到变化，并作出相应的响应。

### 需求

天气预报项目

1. 气象站可以将每天测量到的数据以公告的形式发布出去
2. 需要设计开放性API，便于其他第三方也能接入气象站数据
3. 数据更新，要能实时的通知给第三方

### 普通例子

* 方法一：气象站提供接口后，调用方定时去调用接口更新

* 方法二：气象站在更新自己的数据时，顺便调用调用方的更新接口，实现推送

问题分析：违反ocp原则（开闭原则）

### 改进例子

![image-20210511144539179](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210511144539179.png)

分析：

1. Subject：被观察者，能够通知其他观察者
2. ConcreteSubject：被观察者具体实现类，用集合保存其他观察者
3. Observer：观察者
4. ConreteObserver：观察者实现类

代码：

```java
package com.atguigu.principle.observer;

public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}

```

```java
package com.atguigu.principle.observer;

public interface Observer {
    public void update(float temperature);
}

```

```java
package com.atguigu.principle.observer;

import java.util.ArrayList;

public class WeatherData implements Subject {

    private float temperature;

    // 观察者集合
    private ArrayList<Observer> observers;

    public void setTemperature(float temperature) {
        this.temperature = temperature;
    }

    public float getTemperature() {
        return temperature;
    }

    public WeatherData() {
        observers = new ArrayList<Observer>();
    }

    public void registerObserver(Observer o) {
        observers.add(o);
    }

    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(temperature);
        }
    }
}

```

```java
package com.atguigu.principle.observer;

public class CurrentConditions implements Observer{
    private float temperature;

    public void update(float temperature) {
        this.temperature = temperature;
    }

    public void display() {
        System.out.println("temperature:"+temperature);
    }
}

```

```java
package com.atguigu.principle.observer;

public class Client {
    public static void main(String[] args) {
        // 被观察者
        WeatherData weatherData = new WeatherData();
        // 观察者
        CurrentConditions currentConditions = new CurrentConditions();
        currentConditions.update(1f);
        // 注册
        weatherData.registerObserver(currentConditions);
        // 测试
        System.out.println("更新前气温===================");
        currentConditions.display();
        weatherData.setTemperature(10f);
        weatherData.notifyObservers();
        System.out.println("更新后气温===================");
        currentConditions.display();
    }
}

```

## 19. 中介者模式

### 概念

> 1. **中介者模式**，用一个中介对象来封装一系列的对象交互。中介者使各个对象之间不再显式的相互引用，使其松耦合，可以独立改变它们之间的交互
> 2. 属于行为型模式，使代码易于维护

![image-20210527113420624](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210527113420624.png)

分析：

1. Mediator：抽象中介者
2. Cooleague：抽象同事类
3. ConcreteMediator：具体的中介类，管理所有同事类，完成相应的操作，以集合管理同事类
4. ConcreteColleague：具体同事类，都会依赖中介者对象

### 需求

智能家庭项目：

1. 智能家庭包括各种设备，闹钟、咖啡机、电视机等
2. 主人要看电视时，各个设备可以协同工作，比如：闹钟响起->咖啡机做咖啡->电视机播放

### 改进例子

类图：

![image-20210527114818540](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210527114818540.png)

流程：

1. 创建中介者实现类ConcreteMediator
2. 创建各个同事类对象，比如Alarm、CoffeeMachine、TV
3. 在创建同事类对象的时候，就直接通过构造器，加入到集合中
4. 同事类对象，可以调用sendMessage，最后会取调用ConcreteMediator中的getMessage方法
5. getMessage会根据接收到的同事对象的消息来协调其他同事对象完成任务

代码：

```java
package com.atguigu.principle.mediator;

public abstract class Mediator {
    public abstract void register(String colleagueName, Colleague colleague);

    public abstract void getMessage(int stateChange, String colleague);

    public abstract void sendMessage();
}

```

```java
package com.atguigu.principle.mediator;

import java.util.HashMap;

public class ConcreteMediator extends Mediator{
    private HashMap<String, Colleague> colleagueHashMap;
    private HashMap<String, String> interMap;

    public ConcreteMediator() {
        colleagueHashMap = new HashMap<String, Colleague>();
        interMap = new HashMap<String, String>();
    }


    public void register(String colleagueName, Colleague colleague) {
        colleagueHashMap.put(colleagueName, colleague);

        if (colleague instanceof Alarm) {
            interMap.put("Alarm",colleagueName);
        }
    }

    // 核心方法
    public void getMessage(int stateChange, String colleague) {
        if (colleagueHashMap.get(colleague) instanceof Alarm) {
            if (stateChange == 0) {
                // 指挥其他同事工作
            } else if (stateChange == 1) {
                // 指挥其他同事工作
            }
        }
    }

    public void sendMessage() {

    }
}
```

```java
package com.atguigu.principle.mediator;

// 同事抽象类
public abstract class Colleague {
    private Mediator mediator;
    public String name;

    public Colleague(Mediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public Mediator getMediator() {
        return this.mediator;
    }

    public abstract void sendMessage(int stateChange);
}
```

```java
package com.atguigu.principle.mediator;

public class Alarm extends Colleague {

    public Alarm(Mediator mediator, String name) {
        super(mediator, name);
        // 注册自己
        mediator.register(name,this);
    }

    public void sendAlarm(int stateChange) {
        sendMessage(stateChange);
    }

    public void sendMessage(int stateChange) {
        this.getMediator().getMessage(stateChange,this.name);
    }
}
```

```java
package com.atguigu.principle.mediator;

public class Client {
    public static void main(String[] args) {
        // 中介者对象
        Mediator mediator = new ConcreteMediator();

        // Alarm
        Alarm alarm = new Alarm(mediator,"alarm");
        alarm.sendMessage(0);
        alarm.sendMessage(1);
    }
}
```

## 20. 备忘录模式

### 概念

> 1. **备忘录模式**在不破坏封装性的前提下，捕获一个对象的内部状态，并保存，这样以后就可以恢复到原先保存状态
> 2. 主要是记录一个对象的某种状态，或者某些数据
> 3. 属于行为型模式

![image-20210529190148150](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210529190148150.png)

分析：

1. originator：原始对象
2. Memento：对象状态
3. Caretaker：守护者对象，负责保存多个备忘录对象

### 需求

游戏角色状态恢复问题

游戏角色有攻击力和防御力，在大战BOSS之前保存自身的状态，当大战BOSS后攻击力和防御力下降，从备忘录对象恢复到大战前的状态

### 普通例子

一个游戏角色对应一个游戏角色状态类

分析：

1. 当游戏对象很多时，不利于管理，开销大
2. 简单的备份，需要把备份的数据放到新对象中，暴露了对象内部细节

解决：备忘录模式

### 改进例子

代码：

```java
package com.atguigu.principle.memento;

/**
 * @author Qian
 * @date 2021年05月29日 19:02
 */
public class Originator {

    /**
     * 状态信息
     */
    private String state;

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }

    /**
     * 保存状态
     */
    public Memento saveStateMemento() {
        return new Memento(state);
    }

    /**
     * 通过备忘录对象恢复状态
     */
    public void getStateFromMemento(Memento memento) {
        state = memento.getState();
    }
}
```

```java
package com.atguigu.principle.memento;

/**
 * @author Qian
 * @date 2021年05月29日 19:04
 */
public class Memento {

    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
```

```java
package com.atguigu.principle.memento;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Qian
 * @date 2021年05月29日 19:07
 */
public class Caretaker {

    private List<Memento> mementoList = new ArrayList<Memento>();

    public void add(Memento memento) {
        mementoList.add(memento);
    }

    public Memento get(int index) {
        return mementoList.get(index);
    }
}
```

```java
package com.atguigu.principle.memento;

/**
 * @author Qian
 * @date 2021年05月29日 19:09
 */
public class client {
    public static void main(String[] args) {
        Originator originator = new Originator();
        Caretaker caretaker = new Caretaker();

        originator.setState("状态#1");
        // 保存当前的状态
        caretaker.add(originator.saveStateMemento());

        originator.setState("状态#2");
        caretaker.add(originator.saveStateMemento());
        System.out.println("当前的状态："+originator.getState());


        // 恢复到1
        originator.getStateFromMemento(caretaker.get(0));
        System.out.println("恢复后的状态："+originator.getState());
    }
}
```

简单来说就是单独对状态封装，称为一个单独被管理的类，将角色和状态进行分离管理

## 21. 解释器模式

### 概念

> 1. 编译原理中的**词法分析器**和**语法分析器**分别形成词法单元和构建语法分析书，这里的各个分析器都可以看作解释器
> 2. 给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，用来解释语言中的句子（表达式）
> 3. 例子有：编译器、正则表达式、机器人等

![image-20210530212407028](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210530212407028.png)

分析：

1. Context：含有解释器之外的全局信息
2. AbstractExpression：抽象表达式，声明一个抽象的解释操作，语法树中所有节点所共享
3. TerminalExpression：终结符表达式
4. NonTerminalExpression：非终结符表达式

### 需求

四则运算问题，计算a+b-c的值

### 普通例子

编写一个方法，接收表达式的形式，然后根据用户输入的数值进行解析，得到结果

分析：

1. 如果加入新的运算符，会不易扩展，结构混乱

解决方法：**解释器模式**

### 改进例子

![image-20210530213304611](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210530213304611.png)



代码

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;

/**
 * 抽象表达式
 *
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public abstract class Expression {

    /**
     * a + b - c
     *
     * @param var {a=10,b=20,...}
     */
    public abstract int interpret(HashMap<String, Integer> var);
}
```

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;

/**
 * 变量的解析器
 *
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class VarExpression extends Expression{

    /**
     * a,b,c,具体的值
     */
    private String key;

    public VarExpression(String key) {
        this.key = key;
    }

    @Override
    public int interpret(HashMap<String, Integer> var) {
        return var.get(this.key);
    }
}
```

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;

/**
 * 抽象运算符号解析器
 *
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class SymbolExpression extends Expression {

    protected Expression left;
    protected Expression right;

    public SymbolExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    /**
     * 让子类实现，目前是一个默认实现
     */
    @Override
    public int interpret(HashMap<String, Integer> var) {
        return 0;
    }
}
```

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;

/**
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class SubExpression extends SymbolExpression{

    public SubExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    public int interpret(HashMap<String, Integer> var) {
        return super.left.interpret(var) - super.right.interpret(var);
    }
}
```

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;

/**
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class AddExpression extends SymbolExpression {
    public AddExpression(Expression left, Expression right) {
        super(left, right);
    }

    @Override
    public int interpret(HashMap<String, Integer> var) {
        return super.left.interpret(var) + super.right.interpret(var);
    }
}
```

```java
package com.atguigu.principle.interpreter;

import java.util.HashMap;
import java.util.Stack;

/**
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class Calculator {

    /**
     * 定义表达式
     */
    private Expression expression;

    public Calculator(String expStr) {  // expStr = a + b - c
        Stack<Expression> stack = new Stack<Expression>();
        // 表达式的拆分
        char[] charArray = expStr.toCharArray();

        Expression left = null;
        Expression right = null;

        for (int i = 0; i < charArray.length; i++) {
            switch (charArray[i]) {
                case '+':
                    left = stack.pop();
                    right = new VarExpression(String .valueOf(charArray[++i]));
                    stack.push(new AddExpression(left, right));
                    break;
                case '-':
                    left = stack.pop();
                    right = new VarExpression(String.valueOf(charArray[++i]));
                    stack.push(new SubExpression(left, right));
                    break;
                default:
                    stack.push(new VarExpression(String.valueOf(charArray[i])));
                    break;
            }
        }
        // 弹出最后结果
        this.expression = stack.pop();
    }

    public int run(HashMap<String, Integer> var) {
        return this.expression.interpret(var);
    }
}
```

```java
package com.atguigu.principle.interpreter;

import com.atguigu.principle.adapter.interfaceadapter.Interface4;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashMap;

/**
 * @author Qian
 * @date 2021年05月30日 21:35
 */
public class Client {
    public static void main(String[] args) throws IOException {
        String expStr = getExpStr();
        HashMap<String, Integer> var = getValue(expStr);
        Calculator calculator = new Calculator(expStr);
        System.out.println("运算结果：" + expStr + "=" + calculator.run(var));
    }

    /**
     * 获得表达式
     */
    public static String getExpStr() throws IOException {
        System.out.println("请输入表达式：");
        return (new BufferedReader(new InputStreamReader(System.in))).readLine();
    }

    /**
     * 获得值映射
     */
    public static HashMap<String, Integer> getValue(String expStr) throws IOException {
        HashMap<String, Integer> result = new HashMap<String, Integer>();
        for (char ch : expStr.toCharArray()) {
            if (ch != '+' && ch != '-') {
                if (!result.containsKey(String.valueOf(ch))) {
                    System.out.println("请输入"+ch+"的值：");
                    String s = (new BufferedReader(new InputStreamReader(System.in))).readLine();
                    result.put(String.valueOf(ch), Integer.valueOf(s));
                }
            }
        }
        return result;
    }
}
```

## 22. 状态模式

### 概念

> 1. 主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题，状态之间可以相互转换
> 2. 当一个对象的内在状态改变时，允许改变其行为，对象看起来像是改变了其类

![image-20210603225635574](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210603225635574.png)

分析：

1. Context：环境角色，维护State实例，这个实例定义当前状态
2. State：抽象状态角色，定义接口
3. ConcreteState：具体状态角色，并封装与具体状态对应的行为

### 需求

抽奖活动

1. 加入没参加一次活动要扣除50积分，中奖概率是10%
2. 奖品数量固定，抽完就不能抽奖
3. 活动有四个状态：
   1. 可以抽奖
   2. 不能抽奖
   3. 发放奖品
   4. 奖品领完

![image-20210603224748308](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210603224748308.png)

### 改进例子

![image-20210605172715379](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210605172715379.png)

分析：

1. State：抽象状态类
2. NoRaffle：具体状态类，不能抽奖
3. Activity：活动类，用于承载状态的改变

```java
package com.atguigu.principle.state;

public interface State {

    /**
     * 扣除积分 -50
     */
    public abstract void deduceMoney();

    /**
     * 抽奖
     * @return 抽奖结果
     */
    public abstract boolean raffle();

    /**
     * 发放奖品
     */
    public abstract void dispensePrize();
}
```

```java
package com.atguigu.principle.state;


/**
 * @author Qian
 * @date 2021年06月05日 17:30
 *
 * 不能抽奖状态 -- -50积分 -->  可以抽奖状态
 */
public class NoRaffleState implements State {

    /**
     * 活动引用
     */
    RaffleActivity activity;

    public NoRaffleState(RaffleActivity activity) {
        this.activity = activity;
    }

    public void deduceMoney() {
        System.out.println("积分扣除50，可以抽奖");
        activity.setState(activity.getCanRaffleState());
    }

    public boolean raffle() {
        System.out.println("扣了积分才能抽奖");
        return false;
    }

    public void dispensePrize() {

    }
}
```

```java
package com.atguigu.principle.state;

import java.util.Random;

/**
 * @author Qian
 * @date 2021年06月05日 17:33
 *
 * 已经扣除了积分，可以抽奖
 * 抽到了奖 ---> 发放奖品
 * 没有抽到 ---> 不能抽奖
 */
public class CanRaffleState implements State {

    /**
     * 活动引用
     */
    RaffleActivity activity;

    public CanRaffleState(RaffleActivity activity) {
        this.activity = activity;
    }

    public void deduceMoney() {
        System.out.println("已经扣取过积分了");
    }

    public boolean raffle() {
        System.out.println("正在抽奖，请稍后！");
        Random r = new Random();
        int num = r.nextInt(10);
        if (num == 0) {
            activity.setState(activity.getDispenseState());
            return true;
        } else {
            System.out.println("没有抽中奖品");
            activity.setState(activity.getNoRaffleState());
            return false;
        }
    }

    public void dispensePrize() {
        System.out.println("没有中奖，不能发放奖品");
    }
}
```

```java
package com.atguigu.principle.state;

/**
 * @author Qian
 * @date 2021年06月05日 17:38
 *
 * 发放奖品状态
 *
 */
public class DispenseState implements State {

    /**
     * 活动引用
     */
    RaffleActivity activity;

    public DispenseState(RaffleActivity activity) {
        this.activity = activity;
    }

    public void deduceMoney() {
        System.out.println("不能扣除积分");
    }

    public boolean raffle() {
        System.out.println("不能抽奖");
        return false;
    }

    public void dispensePrize() {
        if (activity.getCount() > 0) {
            System.out.println("恭喜中奖，发放奖品");
            activity.setState(activity.getNoRaffleState());
            activity.subCount();
        } else {
            System.out.println("很遗憾，奖品发放完了");
            activity.setState(activity.getDispenseOutState());
        }
    }
}
```

```java
package com.atguigu.principle.state;

/**
 * @author Qian
 * @date 2021年06月05日 17:43
 *
 * 奖品领完状态，活动结束
 */
public class DispenseOutState implements State {

    /**
     * 活动引用
     */
    RaffleActivity activity;

    public DispenseOutState(RaffleActivity activity) {
        this.activity = activity;
    }

    public void deduceMoney() {
        System.out.println("奖品发送完了，下次参加");
    }

    public boolean raffle() {
        System.out.println("奖品发送完了，下次参加");
        return false;
    }

    public void dispensePrize() {
        System.out.println("奖品发送完了，下次参加");
    }
}
```

```java
package com.atguigu.principle.state;

/**
 * @author Qian
 * @date 2021年06月05日 17:32
 */
public class RaffleActivity {
    State state = null;
    int count = 0;

    State noRaffleState = new NoRaffleState(this);
    State canRaffleState = new CanRaffleState(this);
    State dispenseState = new DispenseState(this);
    State dispenseOutState = new DispenseOutState(this);

    public RaffleActivity(int count) {
        this.count = count;
        this.state = getNoRaffleState();
    }

    public void deduceMoney() {
        state.deduceMoney();
    }

    public void raffle() {
        if (state.raffle()) {
            state.dispensePrize();
        }
    }

    public int getCount() {
        return count;
    }

    public void subCount() {
        count--;
    }

    public void setState(State state) {
        this.state = state;
    }

    public State getNoRaffleState() {
        return noRaffleState;
    }

    public void setNoRaffleState(State noRaffleState) {
        this.noRaffleState = noRaffleState;
    }

    public State getCanRaffleState() {
        return canRaffleState;
    }

    public void setCanRaffleState(State canRaffleState) {
        this.canRaffleState = canRaffleState;
    }

    public State getDispenseState() {
        return dispenseState;
    }

    public void setDispenseState(State dispenseState) {
        this.dispenseState = dispenseState;
    }

    public State getDispenseOutState() {
        return dispenseOutState;
    }

    public void setDispenseOutState(State dispenseOutState) {
        this.dispenseOutState = dispenseOutState;
    }
}
```

```java
package com.atguigu.principle.state;

/**
 * @author Qian
 * @date 2021年06月05日 17:47
 */
public class Client {
    public static void main(String[] args) {

        // 生成活动类
        RaffleActivity activity = new RaffleActivity(1);

        // 抽奖
        for (int i = 0; i < 300; i++) {
            activity.deduceMoney();
            activity.raffle();
        }
    }
}
```

### 实际应用

电商订单状态

## 23. 策略模式

### 概念

> 1. 策略模式中，定义算法簇，分别封装起来，可以相互替换，此模式让算法的变化独立于使用算法的用户
> 2. 体现了几个设计原则
>    1. 把变化的代码从不变的代码这种分离出来
>    2. 针对接口编程，而不是具体类
>    3. 多用组合/聚合，少用继承（客户通过组合方式使用策略）

![image-20210608203925361](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210608203925361.png)

分析：

1. context：有成员变量strategy或其他的策略接口，可以在构造器中选择使用策略
2. StrategyA：策略接口
3. ConcreteStrategyA：具体策略接口

### 需求

鸭子项目

1. 有各类鸭子（野鸭、北京鸭...），有各种行为（叫、飞）
2. 显示鸭子信息

### 普通例子

用父类继承的方法，子类是各类鸭子（野鸭、北京鸭...）

分析：

1. 都继承Duck类，但有些鸭不会飞，但都需要继承重写fly方法，这不好
2. 对类的局部改动，尤其是对超类的局部改动，会有溢出效应，影响其他部分

解决：**策略模式**

### 改进例子

![image-20210608204816739](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210608204816739.png)

分析：将各类行为分成各类策略

代码：

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:49
 */
public interface FlyBehavior {
    /**
     * 飞翔
     */
    void fly();
}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:50
 */
public class GoodFlyBehavior implements FlyBehavior {
    public void fly() {
        System.out.println("飞的好");
    }
}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:51
 */
public class NoFlyBehavior implements FlyBehavior {
    public void fly() {
        System.out.println("不能飞");
    }
}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:25
 */
public abstract class Duck {

    /**
     * 属性，策略接口
     */
    FlyBehavior flyBehavior;

    /**
     * 显示鸭子信息
     */
    public abstract void display();
    
    public void fly() {
        if (flyBehavior != null) {
            flyBehavior.fly();
        }
    }
}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:27
 */
public class PekingDuck extends Duck {

    public PekingDuck() {
        flyBehavior = new NoFlyBehavior();
    }

    @Override
    public void display() {
        System.out.println("这是北京鸭");
    }

}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:27
 */
public class WildDuck extends Duck {

    public WildDuck() {
        flyBehavior = new GoodFlyBehavior();
    }

    @Override
    public void display() {
        System.out.println("这是野鸭");
    }

}
```

```java
package com.atguigu.principle.strategy.improve;

/**
 * @author Qian
 * @date 2021年06月08日 20:57
 */
public class Client {
    public static void main(String[] args) {
        WildDuck wildDuck = new WildDuck();
        wildDuck.fly();

        PekingDuck pekingDuck = new PekingDuck();
        pekingDuck.fly();
    }
}
```

## 24. 职责链模式

### 概念

> 1. 职责链模式：又称责任链模式，为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦
> 2. 职责链模式通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把请求传给下一个接收者
> 3. 属于行为型模式

![image-20210609231546492](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210609231546492.png)

分析：

1. Handler：抽象的处理者，定义了一个处理请求的接口
2. ConcreteHandlerA：具体处理者，处理自身负责的请求，可以访问后继者请求

### 需求

采购教学器材

1. 金额小于等于5000，教学主任审批
2. 金额小于等于10000，院长审批
3. 金额小于等于30000，副校长审批
4. 金额超过30000以上，校长审批

### 普通例子

接到一个采购请求后，根据金额调用对应的审批人完成审批

分析：

1. 如果审批金额发生变化，对应客户端也要变化
2. 客户端必须明确知道，有多少审批人
3. 采购请求和审批人存在强耦合关系，不利于代码扩展维护

解决：**职责链模式**

### 改进例子

![image-20210609232254670](https://chengdu-edu.oss-cn-chengdu.aliyuncs.com/pic-markdown/image-20210609232254670.png)

```java
package com.atguigu.principle.responsibility;

import lombok.Getter;

/**
 * @author Qian
 * @date 2021年06月09日 23:23
 */
@Getter
public class PurchaseRequest {

    /**
     * 请求类型
     */
    private int type;

    /**
     * 请求金额
     */
    private float price = 0.0f;

    /**
     * 请求ID
     */
    private int id = 0;

    public PurchaseRequest(int type, float price, int id) {
        this.type = type;
        this.price = price;
        this.id = id;
    }
}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:25
 */
public abstract class Approver {

    /**
     * 下一个处理者
     */
    Approver approver;
    String name;

    public Approver(String name) {
        this.name = name;
    }

    /**
     * 下一个处理者
     * @param approver
     */
    public void setApprover(Approver approver) {
        this.approver = approver;
    }

    public abstract void processRequest(PurchaseRequest request);

}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:30
 */
public class DepartmentApprover extends Approver {

    public DepartmentApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getPrice() < 5000) {
            System.out.println("请求编号 id="+request.getId()+"被"+this.name+"处理");
        } else {
            approver.processRequest(request);
        }
    }
}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:35
 */
public class CollegeApprover extends Approver {

    public CollegeApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getPrice() >= 5000 && request.getPrice() < 10000) {
            System.out.println("请求编号 id="+request.getId()+"被"+this.name+"处理");
        } else {
            approver.processRequest(request);
        }
    }
}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:37
 */
public class ViceSchoolMasterApprover extends Approver {

    public ViceSchoolMasterApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest request) {
        if (request.getPrice() >= 10000 && request.getPrice() < 30000) {
            System.out.println("请求编号 id="+request.getId()+"被"+this.name+"处理");
        } else {
            approver.processRequest(request);
        }
    }
}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:37
 */
public class SchoolMasterApprover extends Approver {

    public SchoolMasterApprover(String name) {
        super(name);
    }

    @Override
    public void processRequest(PurchaseRequest request) {
        // 目前是链的终点，必须要兜底，所以不用if
        System.out.println("请求编号 id="+request.getId()+"被"+this.name+"处理");
    }
}
```

```java
package com.atguigu.principle.responsibility;

/**
 * @author Qian
 * @date 2021年06月09日 23:38
 */
public class Client {
    public static void main(String[] args) {

        // 请求
        PurchaseRequest purchaseRequest = new PurchaseRequest(1, 3000, 1);

        // 审批人
        DepartmentApprover departmentApprover = new DepartmentApprover("主任");
        CollegeApprover collegeApprover = new CollegeApprover("院长");
        ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover("副校长");
        SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover("校长");

        // 组链
        departmentApprover.setApprover(collegeApprover);
        collegeApprover.setApprover(viceSchoolMasterApprover);
        viceSchoolMasterApprover.setApprover(schoolMasterApprover);

        // 请求处理
        departmentApprover.processRequest(purchaseRequest);
    }
}
```

